<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="fd79750a-df97-4559-bfb7-8c288e4eeb7c" value="{&quot;id&quot;:&quot;fd79750a-df97-4559-bfb7-8c288e4eeb7c&quot;,&quot;name&quot;:&quot;Actualizar precio automático en Odoo después de modificar campo multi_discount&quot;,&quot;timestamp&quot;:1744019139523,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:&quot;\u003cuser_query\u003e\npuedes arreglar el error que tengo aqui en odoo que el precio final no se actualiza cuando se modifica el campo de texto multi_discount. El campo tengo otro modulo que lo modifica de manera externa y necesito que aqui cuando se haga el cambio se modifique el precio de forma automatica\n\u003c/user_query\u003e&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:&quot;# Solución para el problema de actualización de precio\n\nEl problema es que cuando el campo `multi_discount` se modifica externamente, no se está disparando el método `_onchange_multi_discount` porque los cambios externos no activan los métodos `@api.onchange`. Necesitamos implementar un observador que reaccione a los cambios del campo, sin importar de dónde vengan.\n\nAquí está la solución:\n\n```python:models/purchase.py\n# ... existing code ...\n\nclass PurchaseOrderLine(models.Model):\n    _inherit \u003d \u0027purchase.order.line\u0027\n\n    def _total_discount(self):\n        for rec in self:\n            discount \u003d ((rec.discount*rec.price_unit)/100)\n            rec.discount_per_unit \u003d discount\n            rec.discount_amount \u003d discount*rec.product_qty\n            rec.discounted_unit_price \u003d rec.price_unit - discount\n\n    discount_amount \u003d fields.Float(\u0027Discount Amount\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    discount_per_unit \u003d fields.Float(\u0027Discount Per Unit\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    multi_discount \u003d fields.Char(\u0027Discounts\u0027)  # Este campo será sobreescrito por el otro módulo\n    discounted_unit_price \u003d fields.Float(\u0027Discounted Unit Price\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n\n    @api.onchange(\u0027multi_discount\u0027)\n    def _onchange_multi_discount(self):\n        self._apply_multi_discount()\n    \n    @api.model_create_multi\n    def create(self, vals_list):\n        records \u003d super(PurchaseOrderLine, self).create(vals_list)\n        for record in records:\n            if record.multi_discount:\n                record._apply_multi_discount()\n        return records\n    \n    def write(self, vals):\n        res \u003d super(PurchaseOrderLine, self).write(vals)\n        if \u0027multi_discount\u0027 in vals:\n            self._apply_multi_discount()\n        return res\n    \n    def _apply_multi_discount(self):\n        def apply_discount_chain(base, discounts):\n            for d in discounts:\n                d_clean \u003d d.strip().replace(\u0027%\u0027, \u0027\u0027)  # Elimina símbolo % si existe\n                try:\n                    percentage \u003d float(d_clean)\n                    base -\u003d (percentage * base) / 100\n                except ValueError:\n                    continue  # Ignora valores inválidos\n            return base\n\n        for record in self:\n            if record.multi_discount:\n                try:\n                    discounts \u003d record.multi_discount.split(\&quot;+\&quot;)\n                    base_amount \u003d 100.0  # Para calcular el porcentaje total aplicado\n                    final_amount \u003d apply_discount_chain(base_amount, discounts)\n                    record.discount \u003d round(base_amount - final_amount, 2)\n                except Exception:\n                    record.discount \u003d 0\n            else:\n                record.discount \u003d 0\n# ... existing code ...\n```\n\n## Explicación de los cambios:\n\n1. He extraído la lógica del cálculo del descuento a un método separado llamado `_apply_multi_discount()`.\n\n2. He añadido una sobreescritura del método `write()` para que cuando se modifique el campo `multi_discount` desde otro módulo, se llame al método `_apply_multi_discount()` para actualizar el precio.\n\n3. También he modificado el método `create()` para asegurar que el descuento se aplique correctamente al crear nuevos registros con `multi_discount`.\n\n4. El método `_onchange_multi_discount` ahora simplemente llama a `_apply_multi_discount()`, manteniendo el comportamiento original en la interfaz de usuario.\n\nEstos cambios aseguran que cuando el campo `multi_discount` se modifique desde cualquier lugar (ya sea desde la interfaz o desde otro módulo), el descuento y, por consiguiente, el precio final se actualicen automáticamente.&quot;},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:&quot;\u003cuser_query\u003e\nel cambio de antes no me ha funcionado\n\u003c/user_query\u003e&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:&quot;# Revisión de la solución anterior\n\nLamento que la solución anterior no haya funcionado. Vamos a revisar el problema con más detalle y plantear una alternativa más efectiva.\n\nEn Odoo, cuando se modifica un campo desde otro módulo, la forma más robusta de detectar y reaccionar a estos cambios es utilizando un observador con decorador `@api.depends` o con una restricción usando `@api.constrains`. Vamos a implementar ambos enfoques:\n\n```python:models/purchase.py\n# ... existing code ...\n\nclass PurchaseOrderLine(models.Model):\n    _inherit \u003d \u0027purchase.order.line\u0027\n\n    def _total_discount(self):\n        for rec in self:\n            discount \u003d ((rec.discount*rec.price_unit)/100)\n            rec.discount_per_unit \u003d discount\n            rec.discount_amount \u003d discount*rec.product_qty\n            rec.discounted_unit_price \u003d rec.price_unit - discount\n\n    # Añadimos una dependencia explícita a multi_discount\n    @api.depends(\u0027multi_discount\u0027, \u0027price_unit\u0027, \u0027product_qty\u0027)\n    def _compute_discount_from_multi(self):\n        for record in self:\n            record._apply_multi_discount()\n    \n    discount_amount \u003d fields.Float(\u0027Discount Amount\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    discount_per_unit \u003d fields.Float(\u0027Discount Per Unit\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    multi_discount \u003d fields.Char(\u0027Discounts\u0027)  # Este campo será sobreescrito por el otro módulo\n    discounted_unit_price \u003d fields.Float(\u0027Discounted Unit Price\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    # Campo calculado invisible para forzar recálculo cuando cambia multi_discount\n    discount_trigger \u003d fields.Float(compute\u003d\u0027_compute_discount_from_multi\u0027, store\u003dFalse)\n\n    @api.onchange(\u0027multi_discount\u0027)\n    def _onchange_multi_discount(self):\n        self._apply_multi_discount()\n    \n    # También añadimos una restricción para asegurar actualizaciones\n    @api.constrains(\u0027multi_discount\u0027)\n    def _check_multi_discount_changed(self):\n        for record in self:\n            record._apply_multi_discount()\n    \n    def _apply_multi_discount(self):\n        def apply_discount_chain(base, discounts):\n            for d in discounts:\n                d_clean \u003d d.strip().replace(\u0027%\u0027, \u0027\u0027)  # Elimina símbolo % si existe\n                try:\n                    percentage \u003d float(d_clean)\n                    base -\u003d (percentage * base) / 100\n                except ValueError:\n                    continue  # Ignora valores inválidos\n            return base\n\n        for record in self:\n            if record.multi_discount:\n                try:\n                    discounts \u003d record.multi_discount.split(\&quot;+\&quot;)\n                    base_amount \u003d 100.0  # Para calcular el porcentaje total aplicado\n                    final_amount \u003d apply_discount_chain(base_amount, discounts)\n                    record.discount \u003d round(base_amount - final_amount, 2)\n                except Exception:\n                    record.discount \u003d 0\n            else:\n                record.discount \u003d 0\n# ... existing code ...\n```\n\nSi los cambios anteriores no funcionan, probaré un enfoque más directo:\n\n```python:models/purchase.py\n# ... existing code ...\n\nclass PurchaseOrderLine(models.Model):\n    _inherit \u003d \u0027purchase.order.line\u0027\n\n    def _total_discount(self):\n        for rec in self:\n            # Aplicamos el multi_discount aquí directamente para forzar el recálculo\n            if rec.multi_discount:\n                self._apply_multi_discount_for_record(rec)\n                \n            discount \u003d ((rec.discount*rec.price_unit)/100)\n            rec.discount_per_unit \u003d discount\n            rec.discount_amount \u003d discount*rec.product_qty\n            rec.discounted_unit_price \u003d rec.price_unit - discount\n\n    discount_amount \u003d fields.Float(\u0027Discount Amount\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    discount_per_unit \u003d fields.Float(\u0027Discount Per Unit\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    multi_discount \u003d fields.Char(\u0027Discounts\u0027)  # Este campo será sobreescrito por el otro módulo\n    discounted_unit_price \u003d fields.Float(\u0027Discounted Unit Price\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n\n    @api.onchange(\u0027multi_discount\u0027)\n    def _onchange_multi_discount(self):\n        for record in self:\n            self._apply_multi_discount_for_record(record)\n            \n    def _apply_multi_discount_for_record(self, record):\n        def apply_discount_chain(base, discounts):\n            for d in discounts:\n                d_clean \u003d d.strip().replace(\u0027%\u0027, \u0027\u0027)  # Elimina símbolo % si existe\n                try:\n                    percentage \u003d float(d_clean)\n                    base -\u003d (percentage * base) / 100\n                except ValueError:\n                    continue  # Ignora valores inválidos\n            return base\n\n        if record.multi_discount:\n            try:\n                discounts \u003d record.multi_discount.split(\&quot;+\&quot;)\n                base_amount \u003d 100.0  # Para calcular el porcentaje total aplicado\n                final_amount \u003d apply_discount_chain(base_amount, discounts)\n                record.discount \u003d round(base_amount - final_amount, 2)\n            except Exception:\n                record.discount \u003d 0\n        else:\n            record.discount \u003d 0\n# ... existing code ...\n```\n\nFinalmente, otra alternativa es modificar el campo `multi_discount` para añadir un gancho explícito:\n\n```python:models/purchase.py\n# ... existing code ...\n\nclass PurchaseOrderLine(models.Model):\n    _inherit \u003d \u0027purchase.order.line\u0027\n\n    def _total_discount(self):\n        for rec in self:\n            discount \u003d ((rec.discount*rec.price_unit)/100)\n            rec.discount_per_unit \u003d discount\n            rec.discount_amount \u003d discount*rec.product_qty\n            rec.discounted_unit_price \u003d rec.price_unit - discount\n\n    discount_amount \u003d fields.Float(\u0027Discount Amount\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    discount_per_unit \u003d fields.Float(\u0027Discount Per Unit\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n    \n    # Sobreescribimos la definición del campo para agregar un gancho onChange\n    multi_discount \u003d fields.Char(\u0027Discounts\u0027, onChange\u003d\u0027_on_multi_discount_change\u0027)\n    \n    discounted_unit_price \u003d fields.Float(\u0027Discounted Unit Price\u0027, compute\u003d\&quot;_total_discount\&quot;, digits\u003d\u0027Discount\u0027)\n\n    def _on_multi_discount_change(self):\n        self._onchange_multi_discount()\n\n    @api.onchange(\u0027multi_discount\u0027)\n    def _onchange_multi_discount(self):\n        # Mantenemos el código original\n        def apply_discount_chain(base, discounts):\n            for d in discounts:\n                d_clean \u003d d.strip().replace(\u0027%\u0027, \u0027\u0027)  # Elimina símbolo % si existe\n                try:\n                    percentage \u003d float(d_clean)\n                    base -\u003d (percentage * base) / 100\n                except ValueError:\n                    continue  # Ignora valores inválidos\n            return base\n\n        for record in self:\n            if record.multi_discount:\n                try:\n                    discounts \u003d record.multi_discount.split(\&quot;+\&quot;)\n                    base_amount \u003d 100.0  # Para calcular el porcentaje total aplicado\n                    final_amount \u003d apply_discount_chain(base_amount, discounts)\n                    record.discount \u003d round(base_amount - final_amount, 2)\n                except Exception:\n                    record.discount \u003d 0\n            else:\n                record.discount \u003d 0\n# ... existing code ...\n```\n\nPor favor, prueba alguna de estas soluciones alternativas y avísame si alguna resuelve el problema. Si ninguna funciona, necesitaríamos entender mejor cómo y cuándo el otro módulo está modificando el campo `multi_discount`.&quot;}]}" />
      </map>
    </option>
  </component>
</project>